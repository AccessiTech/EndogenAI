"""ChromaDB vector store adapter — the default EndogenAI backend.

The ChromaDB adapter supports two modes:
- ``http``     — connects to an external ChromaDB server (docker-compose default, port 8000).
- ``embedded`` — runs ChromaDB in-process (lightweight CI / unit tests).

Embeddings are generated by :class:`EmbeddingClient` (Ollama by default) before
being passed to ChromaDB.  ChromaDB's built-in embedding functions are NOT used
so that the embedding configuration is unified across all adapters.

Usage::

    from endogenai_vector_store import ChromaAdapter, ChromaConfig, EmbeddingConfig

    async with ChromaAdapter(
        config=ChromaConfig(mode="http", host="localhost", port=8000),
        embedding_config=EmbeddingConfig(),
    ) as adapter:
        await adapter.create_collection(CreateCollectionRequest(collection_name="brain.knowledge"))
        await adapter.upsert(UpsertRequest(collection_name="brain.knowledge", items=[item]))
        resp = await adapter.query(QueryRequest(collection_name="brain.knowledge", query_text="..."))
"""

from __future__ import annotations

import asyncio
import datetime
import uuid
from functools import lru_cache
from typing import Any, cast

import chromadb
import structlog
from chromadb.config import Settings

from endogenai_vector_store.embedding import EmbeddingClient
from endogenai_vector_store.interface import AdapterError, VectorStoreAdapter
from endogenai_vector_store.models import (
    ChromaConfig,
    ChromaMode,
    CollectionInfo,
    CreateCollectionRequest,
    CreateCollectionResponse,
    DeleteRequest,
    DeleteResponse,
    DropCollectionRequest,
    DropCollectionResponse,
    EmbeddingConfig,
    ListCollectionsResponse,
    MemoryItem,
    MemoryType,
    QueryRequest,
    QueryResponse,
    QueryResult,
    UpsertRequest,
    UpsertResponse,
)

logger: structlog.BoundLogger = structlog.get_logger(__name__)

_EXCLUDE_FROM_METADATA = {"embedding", "content", "collection_name", "id"}


def _item_to_metadata(item: MemoryItem) -> dict[str, Any]:
    """Convert a MemoryItem to a ChromaDB-safe metadata dict.

    ChromaDB metadata values must be str | int | float | bool.
    Complex types (lists, dicts) are JSON-encoded.
    """
    import json

    meta: dict[str, Any] = {}
    for field_name, field_value in item.model_dump(exclude=_EXCLUDE_FROM_METADATA).items():
        if field_value is None:
            continue
        if isinstance(field_value, (str, int, float, bool)):
            meta[field_name] = field_value
        else:
            meta[field_name] = json.dumps(field_value)
    return meta


def _chroma_hit_to_item(
    doc_id: str,
    document: str,
    metadata: dict[str, Any],
    embedding: list[float] | None,
) -> MemoryItem:
    """Reconstruct a MemoryItem from ChromaDB query result fields."""
    import json

    def _load(key: str, default: Any = None) -> Any:
        val = metadata.get(key, default)
        if isinstance(val, str):
            try:
                return json.loads(val)
            except (ValueError, TypeError):
                return val
        return val

    return MemoryItem(
        id=doc_id,
        collection_name=metadata.get("collection_name", "brain.unknown"),
        content=document,
        type=MemoryType(metadata.get("type", "working")),
        source_module=metadata.get("source_module", ""),
        importance_score=float(metadata.get("importance_score", 0.5)),
        created_at=metadata.get("created_at", datetime.datetime.utcnow().isoformat()),
        updated_at=metadata.get("updated_at"),
        expires_at=metadata.get("expires_at"),
        access_count=int(metadata.get("access_count", 0)),
        last_accessed_at=metadata.get("last_accessed_at"),
        metadata=_load("metadata", {}),
        tags=_load("tags", []),
        embedding=embedding,
        embedding_model=metadata.get("embedding_model"),
        parent_id=metadata.get("parent_id"),
        related_ids=_load("related_ids", []),
    )


class ChromaAdapter(VectorStoreAdapter):
    """ChromaDB implementation of VectorStoreAdapter."""

    def __init__(
        self,
        config: ChromaConfig | None = None,
        embedding_config: EmbeddingConfig | None = None,
    ) -> None:
        self._config = config or ChromaConfig()
        self._embedding_config = embedding_config or EmbeddingConfig()
        self._client: chromadb.AsyncClientAPI | None = None
        self._embedder = EmbeddingClient(self._embedding_config)

    # ------------------------------------------------------------------
    # Lifecycle
    # ------------------------------------------------------------------

    async def connect(self) -> None:
        await self._embedder.connect()
        cfg = self._config

        if cfg.mode == ChromaMode.EMBEDDED:
            settings = Settings(
                is_persistent=True,
                persist_directory=cfg.persist_directory or "/tmp/chroma-test",
                anonymized_telemetry=False,
            )
            self._client = await chromadb.AsyncEphemeralClient(settings=settings)  # type: ignore[assignment]
        else:
            self._client = await chromadb.AsyncHttpClient(  # type: ignore[assignment]
                host=cfg.host,
                port=cfg.port,
                ssl=cfg.ssl,
                headers=cfg.headers or {},
                settings=Settings(anonymized_telemetry=False),
                tenant=cfg.tenant,
                database=cfg.database,
            )

        logger.info(
            "chroma.connected",
            mode=cfg.mode,
            host=cfg.host if cfg.mode == ChromaMode.HTTP else "embedded",
            port=cfg.port if cfg.mode == ChromaMode.HTTP else None,
        )

    async def close(self) -> None:
        await self._embedder.close()
        logger.info("chroma.closed")

    # ------------------------------------------------------------------
    # Helpers
    # ------------------------------------------------------------------

    def _assert_connected(self) -> chromadb.AsyncClientAPI:
        if self._client is None:
            raise AdapterError(
                "ChromaAdapter is not connected — call connect() or use as async context manager.",
                backend="chromadb",
                retryable=False,
            )
        return self._client

    # ------------------------------------------------------------------
    # Operations
    # ------------------------------------------------------------------

    async def upsert(self, request: UpsertRequest) -> UpsertResponse:
        client = self._assert_connected()

        try:
            collection = await client.get_or_create_collection(request.collection_name)
        except Exception as exc:
            raise AdapterError(
                f"ChromaDB get_or_create_collection failed: {exc}",
                backend="chromadb",
                retryable=True,
            ) from exc

        texts = [item.content for item in request.items]
        vectors = await self._embedder.embed(texts)
        model_name = self._embedding_config.model

        ids: list[str] = []
        documents: list[str] = []
        embeddings: list[list[float]] = []
        metadatas: list[dict[str, Any]] = []

        for item, vector in zip(request.items, vectors, strict=True):
            item.embedding = vector
            item.embedding_model = model_name
            ids.append(item.id)
            documents.append(item.content)
            embeddings.append(vector)
            metadatas.append(_item_to_metadata(item))

        try:
            await collection.upsert(
                ids=ids,
                documents=documents,
                embeddings=embeddings,
                metadatas=metadatas,
            )
        except Exception as exc:
            raise AdapterError(
                f"ChromaDB upsert failed: {exc}",
                backend="chromadb",
                retryable=True,
            ) from exc

        logger.info("chroma.upsert", collection=request.collection_name, count=len(ids))
        return UpsertResponse(upserted_ids=ids)

    async def query(self, request: QueryRequest) -> QueryResponse:
        client = self._assert_connected()

        try:
            collection = await client.get_collection(request.collection_name)
        except Exception as exc:
            raise AdapterError(
                f"ChromaDB get_collection failed: {exc}",
                backend="chromadb",
                retryable=False,
            ) from exc

        query_vector = await self._embedder.embed_one(request.query_text)

        query_kwargs: dict[str, Any] = {
            "query_embeddings": [query_vector],
            "n_results": request.n_results,
            "include": ["documents", "metadatas", "embeddings", "distances"],
        }
        if request.where:
            query_kwargs["where"] = request.where
        if request.where_document:
            query_kwargs["where_document"] = {"$contains": request.where_document}

        try:
            raw = await collection.query(**query_kwargs)
        except Exception as exc:
            raise AdapterError(
                f"ChromaDB query failed: {exc}",
                backend="chromadb",
                retryable=True,
            ) from exc

        results: list[QueryResult] = []
        if raw["ids"] and raw["ids"][0]:
            ids_list = raw["ids"][0]
            docs_list = raw["documents"][0] if raw.get("documents") else [""] * len(ids_list)
            meta_list = raw["metadatas"][0] if raw.get("metadatas") else [{}] * len(ids_list)
            emb_list = raw["embeddings"][0] if raw.get("embeddings") else [None] * len(ids_list)
            dist_list = raw["distances"][0] if raw.get("distances") else [1.0] * len(ids_list)

            for doc_id, doc, meta, emb, dist in zip(
                ids_list, docs_list, meta_list, emb_list, dist_list, strict=True
            ):
                # Chroma returns L2 distance; convert to cosine similarity-like score
                score = max(0.0, 1.0 - dist / 2.0)
                item = _chroma_hit_to_item(doc_id, doc, meta or {}, emb)
                results.append(QueryResult(item=item, score=score))

        logger.debug(
            "chroma.query",
            collection=request.collection_name,
            query=request.query_text[:80],
            n_results=len(results),
        )
        return QueryResponse(results=results)

    async def delete(self, request: DeleteRequest) -> DeleteResponse:
        client = self._assert_connected()

        try:
            collection = await client.get_collection(request.collection_name)
            await collection.delete(ids=request.ids)
        except Exception as exc:
            raise AdapterError(
                f"ChromaDB delete failed: {exc}",
                backend="chromadb",
                retryable=True,
            ) from exc

        logger.info(
            "chroma.delete", collection=request.collection_name, count=len(request.ids)
        )
        return DeleteResponse(deleted_ids=request.ids)

    async def create_collection(
        self, request: CreateCollectionRequest
    ) -> CreateCollectionResponse:
        client = self._assert_connected()

        try:
            existing = await client.list_collections()
            existing_names = {c.name for c in existing}
        except Exception as exc:
            raise AdapterError(
                f"ChromaDB list_collections failed: {exc}",
                backend="chromadb",
                retryable=True,
            ) from exc

        already_existed = request.collection_name in existing_names

        try:
            await client.get_or_create_collection(
                name=request.collection_name,
                metadata=request.metadata or None,
            )
        except Exception as exc:
            raise AdapterError(
                f"ChromaDB create_collection failed: {exc}",
                backend="chromadb",
                retryable=False,
            ) from exc

        logger.info(
            "chroma.create_collection",
            collection=request.collection_name,
            created=not already_existed,
        )
        return CreateCollectionResponse(
            collection_name=request.collection_name,
            created=not already_existed,
        )

    async def drop_collection(self, request: DropCollectionRequest) -> DropCollectionResponse:
        client = self._assert_connected()

        try:
            existing = await client.list_collections()
            existing_names = {c.name for c in existing}
        except Exception as exc:
            raise AdapterError(
                f"ChromaDB list_collections failed: {exc}",
                backend="chromadb",
                retryable=True,
            ) from exc

        if request.collection_name not in existing_names:
            return DropCollectionResponse(collection_name=request.collection_name, dropped=False)

        try:
            await client.delete_collection(request.collection_name)
        except Exception as exc:
            raise AdapterError(
                f"ChromaDB delete_collection failed: {exc}",
                backend="chromadb",
                retryable=False,
            ) from exc

        logger.info("chroma.drop_collection", collection=request.collection_name)
        return DropCollectionResponse(collection_name=request.collection_name, dropped=True)

    async def list_collections(self) -> ListCollectionsResponse:
        client = self._assert_connected()

        try:
            raw = await client.list_collections()
        except Exception as exc:
            raise AdapterError(
                f"ChromaDB list_collections failed: {exc}",
                backend="chromadb",
                retryable=True,
            ) from exc

        collections = [
            CollectionInfo(
                name=c.name,
                count=None,  # count() is a separate async call; omit for list efficiency
                metadata={k: str(v) for k, v in (c.metadata or {}).items()},
            )
            for c in raw
        ]
        return ListCollectionsResponse(collections=collections)
