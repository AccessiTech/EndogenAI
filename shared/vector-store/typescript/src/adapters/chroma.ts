/**
 * ChromaDB adapter for the EndogenAI vector store.
 *
 * Uses chromadb npm package (v1.x API) and Ollama for embeddings.
 * Embeddings are generated by a lightweight fetch-based client — the chromadb
 * built-in embedding functions are NOT used so that embedding configuration
 * is unified across all adapters.
 *
 * @example
 * ```ts
 * import { ChromaAdapter } from "@accessitech/vector-store";
 *
 * const adapter = new ChromaAdapter({ host: "localhost", port: 8000 });
 * await adapter.connect();
 * await adapter.createCollection({ collectionName: "brain.knowledge" });
 * ```
 */

import { ChromaClient } from "chromadb";
import type { IEmbeddingFunction, Collection } from "chromadb";
import type {
  ChromaConfig,
  CollectionInfo,
  CreateCollectionRequest,
  CreateCollectionResponse,
  DeleteRequest,
  DeleteResponse,
  DropCollectionRequest,
  DropCollectionResponse,
  EmbeddingConfig,
  ListCollectionsResponse,
  MemoryItem,
  QueryRequest,
  QueryResponse,
  QueryResult,
  UpsertRequest,
  UpsertResponse,
} from "../models.js";
import { DEFAULT_CHROMA_CONFIG, DEFAULT_EMBEDDING_CONFIG } from "../models.js";
import { AdapterError, type VectorStoreAdapter } from "../interface.js";

// ---------------------------------------------------------------------------
// Embedding client (inline, Ollama / OpenAI-compatible)
// ---------------------------------------------------------------------------

async function embedTexts(texts: string[], config: EmbeddingConfig): Promise<number[][]> {
  if (texts.length === 0) return [];

  const batchSize = config.batchSize ?? 32;
  const results: number[][] = [];

  for (let i = 0; i < texts.length; i += batchSize) {
    const batch = texts.slice(i, i + batchSize);
    const batchVectors = await embedBatch(batch, config);
    results.push(...batchVectors);
  }
  return results;
}

async function embedBatch(texts: string[], config: EmbeddingConfig): Promise<number[][]> {
  const { provider, model, baseUrl, timeoutMs = 30_000 } = config;

  const controller = new AbortController();
  const timer = setTimeout(() => controller.abort(), timeoutMs);

  try {
    if (provider === "ollama") {
      const res = await fetch(`${baseUrl}/api/embed`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ model, input: texts }),
        signal: controller.signal,
      });

      if (!res.ok) {
        throw new AdapterError(
          `Ollama embed failed: HTTP ${res.status}`,
          "ollama",
          res.status >= 500,
        );
      }

      const data = (await res.json()) as { embeddings?: number[][]; embedding?: number[] };
      const embeddings = data.embeddings ?? (data.embedding ? [data.embedding] : []);
      if (embeddings.length === 0) {
        throw new AdapterError("Ollama embed returned empty embeddings", "ollama", false);
      }
      return embeddings;
    } else {
      // OpenAI-compatible endpoint
      const apiKey = process.env["ENDOGEN_EMBEDDING_API_KEY"] ?? "";
      const res = await fetch(`${baseUrl}/v1/embeddings`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          ...(apiKey ? { Authorization: `Bearer ${apiKey}` } : {}),
        },
        body: JSON.stringify({ model, input: texts }),
        signal: controller.signal,
      });

      if (!res.ok) {
        throw new AdapterError(
          `Embedding API failed: HTTP ${res.status}`,
          provider,
          res.status >= 500,
        );
      }

      const data = (await res.json()) as { data: { index: number; embedding: number[] }[] };
      return data.data.sort((a, b) => a.index - b.index).map((d) => d.embedding);
    }
  } finally {
    clearTimeout(timer);
  }
}

// ---------------------------------------------------------------------------
// Metadata helpers
// ---------------------------------------------------------------------------

type ChromaMetadata = Record<string, string | number | boolean>;

function itemToMetadata(item: MemoryItem): ChromaMetadata {
  const meta: ChromaMetadata = {
    collection_name: item.collectionName,
    type: item.type,
    source_module: item.sourceModule,
    importance_score: item.importanceScore,
    created_at: item.createdAt,
    access_count: item.accessCount,
    tags: JSON.stringify(item.tags),
    metadata: JSON.stringify(item.metadata),
    related_ids: JSON.stringify(item.relatedIds),
  };
  if (item.updatedAt) meta["updated_at"] = item.updatedAt;
  if (item.expiresAt) meta["expires_at"] = item.expiresAt;
  if (item.lastAccessedAt) meta["last_accessed_at"] = item.lastAccessedAt;
  if (item.embeddingModel) meta["embedding_model"] = item.embeddingModel;
  if (item.parentId) meta["parent_id"] = item.parentId;
  return meta;
}

function metadataToItem(
  id: string,
  document: string,
  metadata: ChromaMetadata,
  embedding?: number[],
): MemoryItem {
  const safeJson = (v: unknown, fallback: unknown): unknown => {
    if (typeof v === "string") {
      try {
        return JSON.parse(v);
      } catch {
        return fallback;
      }
    }
    return fallback;
  };

  return {
    id,
    collectionName: String(metadata["collection_name"] ?? "brain.unknown"),
    content: document,
    type: (metadata["type"] as MemoryItem["type"]) ?? "working",
    sourceModule: String(metadata["source_module"] ?? ""),
    importanceScore: Number(metadata["importance_score"] ?? 0.5),
    createdAt: String(metadata["created_at"] ?? new Date().toISOString()),
    updatedAt: metadata["updated_at"] ? String(metadata["updated_at"]) : undefined,
    expiresAt: metadata["expires_at"] ? String(metadata["expires_at"]) : undefined,
    accessCount: Number(metadata["access_count"] ?? 0),
    lastAccessedAt: metadata["last_accessed_at"] ? String(metadata["last_accessed_at"]) : undefined,
    metadata: safeJson(metadata["metadata"], {}) as Record<string, unknown>,
    tags: safeJson(metadata["tags"], []) as string[],
    embedding,
    embeddingModel: metadata["embedding_model"] ? String(metadata["embedding_model"]) : undefined,
    parentId: metadata["parent_id"] ? String(metadata["parent_id"]) : undefined,
    relatedIds: safeJson(metadata["related_ids"], []) as string[],
  };
}

// No-op embedding function passed to getCollection/getOrCreateCollection.
// Actual embeddings are generated by our EmbeddingClient — ChromaDB's built-in
// embedding function is intentionally bypassed.
const NO_OP_EF: IEmbeddingFunction = {
  generate: async (_input: string[]): Promise<number[][]> => [],
};

// ---------------------------------------------------------------------------
// ChromaAdapter
// ---------------------------------------------------------------------------

export class ChromaAdapter implements VectorStoreAdapter {
  private client: ChromaClient | null = null;
  private readonly config: Required<ChromaConfig>;
  private readonly embeddingConfig: EmbeddingConfig;

  constructor(config?: Partial<ChromaConfig>, embeddingConfig?: Partial<EmbeddingConfig>) {
    this.config = { ...DEFAULT_CHROMA_CONFIG, ...config } as Required<ChromaConfig>;
    this.embeddingConfig = { ...DEFAULT_EMBEDDING_CONFIG, ...embeddingConfig };
  }

  async connect(): Promise<void> {
    const { mode, host, port, ssl, headers, tenant, database } = this.config;

    if (mode === "embedded") {
      // chromadb v1.x removed the embedded/ephemeral client.
      // Use mode='http' and point to a local ChromaDB server instead.
      // For tests, use Testcontainers (see tests/chroma.test.ts).
      throw new AdapterError(
        "Embedded mode is not supported in chromadb v1.x. " +
          "Use mode='http' and run a local ChromaDB server or Testcontainer.",
        "chromadb",
        false,
      );
    }

    const protocol = ssl ? "https" : "http";
    this.client = new ChromaClient({
      path: `${protocol}://${host}:${port}`,
      fetchOptions: { headers: headers ?? {} },
      tenant,
      database,
    });
  }

  async close(): Promise<void> {
    this.client = null;
  }

  private assertConnected(): ChromaClient {
    if (!this.client) {
      throw new AdapterError(
        "ChromaAdapter is not connected — call connect() first.",
        "chromadb",
        false,
      );
    }
    return this.client;
  }

  private async getCollection(name: string): Promise<Collection> {
    const client = this.assertConnected();
    try {
      return await client.getCollection({ name, embeddingFunction: NO_OP_EF });
    } catch (err) {
      throw new AdapterError(
        `ChromaDB getCollection failed for "${name}": ${String(err)}`,
        "chromadb",
        false,
      );
    }
  }

  async upsert(request: UpsertRequest): Promise<UpsertResponse> {
    const client = this.assertConnected();
    let collection: Collection;
    try {
      collection = await client.getOrCreateCollection({
        name: request.collectionName,
        embeddingFunction: NO_OP_EF,
      });
    } catch (err) {
      throw new AdapterError(
        `ChromaDB getOrCreateCollection failed: ${String(err)}`,
        "chromadb",
        true,
      );
    }

    const texts = request.items.map((i) => i.content);
    const vectors = await embedTexts(texts, this.embeddingConfig);

    const ids: string[] = [];
    const documents: string[] = [];
    const embeddings: number[][] = [];
    const metadatas: ChromaMetadata[] = [];

    for (let idx = 0; idx < request.items.length; idx++) {
      const item = request.items[idx]!;
      const vector = vectors[idx]!;
      item.embedding = vector;
      item.embeddingModel = this.embeddingConfig.model;
      ids.push(item.id);
      documents.push(item.content);
      embeddings.push(vector);
      metadatas.push(itemToMetadata(item));
    }

    try {
      await collection.upsert({ ids, documents, embeddings, metadatas });
    } catch (err) {
      throw new AdapterError(`ChromaDB upsert failed: ${String(err)}`, "chromadb", true);
    }

    return { upsertedIds: ids };
  }

  async query(request: QueryRequest): Promise<QueryResponse> {
    const collection = await this.getCollection(request.collectionName);
    const [queryVector] = await embedTexts([request.queryText], this.embeddingConfig);
    if (!queryVector) throw new AdapterError("Failed to embed query text", "chromadb", true);

    const queryParams: Record<string, unknown> = {
      queryEmbeddings: [queryVector],
      nResults: request.nResults ?? 10,
      include: ["documents", "metadatas", "embeddings", "distances"],
    };
    if (request.where) queryParams["where"] = request.where;
    if (request.whereDocument)
      queryParams["whereDocument"] = { $contains: request.whereDocument };

    let raw: Awaited<ReturnType<Collection["query"]>>;
    try {
      raw = await collection.query(queryParams as Parameters<Collection["query"]>[0]);
    } catch (err) {
      throw new AdapterError(`ChromaDB query failed: ${String(err)}`, "chromadb", true);
    }

    const results: QueryResult[] = [];
    const idsList = raw.ids[0] ?? [];
    const docsList = raw.documents?.[0] ?? [];
    const metaList = raw.metadatas?.[0] ?? [];
    const embList = (raw.embeddings as number[][] | null | undefined)?.[0] ?? [];
    const distList = raw.distances?.[0] ?? [];

    for (let i = 0; i < idsList.length; i++) {
      const id = idsList[i]!;
      const doc = docsList[i] ?? "";
      const meta = (metaList[i] ?? {}) as ChromaMetadata;
      const emb = (embList[i] as number[] | undefined) ?? undefined;
      const dist = (distList[i] as number | undefined) ?? 1.0;
      const score = Math.max(0, 1 - dist / 2);
      results.push({ item: metadataToItem(id, doc, meta, emb), score });
    }

    return { results };
  }

  async delete(request: DeleteRequest): Promise<DeleteResponse> {
    const collection = await this.getCollection(request.collectionName);
    try {
      await collection.delete({ ids: request.ids });
    } catch (err) {
      throw new AdapterError(`ChromaDB delete failed: ${String(err)}`, "chromadb", true);
    }
    return { deletedIds: request.ids };
  }

  async createCollection(request: CreateCollectionRequest): Promise<CreateCollectionResponse> {
    const client = this.assertConnected();
    let existing: string[];
    try {
      existing = await client.listCollections();
    } catch (err) {
      throw new AdapterError(`ChromaDB listCollections failed: ${String(err)}`, "chromadb", true);
    }

    const alreadyExists = existing.includes(request.collectionName);
    try {
      await client.getOrCreateCollection({
        name: request.collectionName,
        embeddingFunction: NO_OP_EF,
        metadata: request.metadata,
      });
    } catch (err) {
      throw new AdapterError(`ChromaDB createCollection failed: ${String(err)}`, "chromadb", false);
    }

    return { collectionName: request.collectionName, created: !alreadyExists };
  }

  async dropCollection(request: DropCollectionRequest): Promise<DropCollectionResponse> {
    const client = this.assertConnected();
    const existing = await client.listCollections();
    if (!existing.includes(request.collectionName)) {
      return { collectionName: request.collectionName, dropped: false };
    }

    try {
      await client.deleteCollection({ name: request.collectionName });
    } catch (err) {
      throw new AdapterError(`ChromaDB deleteCollection failed: ${String(err)}`, "chromadb", false);
    }
    return { collectionName: request.collectionName, dropped: true };
  }

  async listCollections(): Promise<ListCollectionsResponse> {
    const client = this.assertConnected();
    let raw: { name: string; id: string; metadata?: Record<string, unknown> | null }[];
    try {
      raw = await client.listCollectionsAndMetadata();
    } catch (err) {
      throw new AdapterError(`ChromaDB listCollections failed: ${String(err)}`, "chromadb", true);
    }

    const collections: CollectionInfo[] = raw.map((c) => ({
      name: c.name,
      metadata: (c.metadata as Record<string, string> | undefined) ?? {},
    }));
    return { collections };
  }
}
